package main

import (
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/tmc/covutil/coverage"
)

// generateWorkingSynthetic creates a synthetic coverage file by copying working format exactly
func generateWorkingSynthetic(outputDir string) error {
	// Create metadata file name with known hash
	metaHash := [16]byte{0x89, 0xe7, 0x9f, 0x57, 0x72, 0xa0, 0xbf, 0x90, 0xb2, 0xd8, 0x78, 0x44, 0x04, 0xda, 0x95, 0x19}
	metaFileName := fmt.Sprintf("%s.%x", coverage.MetaFilePref, metaHash[:])
	metaFilePath := filepath.Join(outputDir, metaFileName)

	f, err := os.Create(metaFilePath)
	if err != nil {
		return fmt.Errorf("failed to create metadata file: %w", err)
	}
	defer f.Close()

	// Copy the exact working metadata file bytes
	workingMetadata := []byte{
		// Header (64 bytes)
		0x00, 0x63, 0x76, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x0f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x89, 0xe7, 0x9f, 0x57, 0x72, 0xa0, 0xbf, 0x90,
		0xb2, 0xd8, 0x78, 0x44, 0x04, 0xda, 0x95, 0x19, 0x48, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// Package offsets and lengths
		0xc5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xc5, 0x00, 0x00, 0x00, 0x02, 0x00,
		0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xcf, 0x18, 0x8b, 0xc5, 0xf8, 0xd1,
		0x62, 0xed, 0xb7, 0xcf, 0x91, 0xc5, 0x47, 0x21, 0xb8, 0x9d, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
		0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xbc, 0x00, 0x00, 0x00, 0x05, 0x00, 0x32, 0x67, 0x69, 0x74,
		0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2f,
		0x74, 0x65, 0x73, 0x74, 0x70, 0x6b, 0x67, 0x04, 0x6d, 0x61, 0x69, 0x6e, 0x16, 0x67, 0x69, 0x74,
		0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x3a,
		0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x65, 0x78, 0x61, 0x6d, 0x70,
		0x6c, 0x65, 0x2f, 0x74, 0x65, 0x73, 0x74, 0x70, 0x6b, 0x67, 0x2f, 0x6d, 0x61, 0x69, 0x6e, 0x2e,
		0x67, 0x6f, 0x01, 0x02, 0x04, 0x05, 0x0d, 0x07, 0x02, 0x01, 0x00, 0xc5, 0x00, 0x00, 0x00, 0x02,
		0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xcf, 0x18, 0x8b, 0xc5, 0xf8,
		0xd1, 0x62, 0xed, 0xb7, 0xcf, 0x91, 0xc5, 0x47, 0x21, 0xb8, 0x9d, 0x00, 0x00, 0x00, 0x00, 0x05,
		0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xbc, 0x00, 0x00, 0x00, 0x05, 0x00, 0x32, 0x67, 0x69,
	}

	if _, err := f.Write(workingMetadata); err != nil {
		return fmt.Errorf("failed to write metadata: %w", err)
	}

	fmt.Printf("Generated working metadata file: %s\n", metaFilePath)
	
	// Generate counter file
	pid := os.Getpid()
	timestamp := time.Now().UnixNano()
	counterFileName := fmt.Sprintf(coverage.CounterFileTempl, coverage.CounterFilePref, metaHash[:], pid, timestamp)
	counterFilePath := filepath.Join(outputDir, counterFileName)

	cf, err := os.Create(counterFilePath)
	if err != nil {
		return fmt.Errorf("failed to create counter file: %w", err)
	}
	defer cf.Close()

	// Simple counter file structure
	counterData := []byte{
		// Header (32 bytes)
		0x00, 0x63, 0x77, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x89, 0xe7, 0x9f, 0x57, 0x72, 0xa0, 0xbf, 0x90,
		0xb2, 0xd8, 0x78, 0x44, 0x04, 0xda, 0x95, 0x19, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// Segment data - copy from working file
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x08, 0x06, 0x47, 0x4f, 0x41, 0x52, 0x43, 0x48, 0x05, 0x61, 0x72, 0x6d, 0x36, 0x34, 0x04, 0x47,
		0x4f, 0x4f, 0x53, 0x06, 0x64, 0x61, 0x72, 0x77, 0x69, 0x6e, 0x04, 0x61, 0x72, 0x67, 0x63, 0x01,
		0x31, 0x05, 0x61, 0x72, 0x67, 0x76, 0x30, 0x14, 0x2f, 0x70, 0x61, 0x74, 0x68, 0x2f, 0x74, 0x6f,
		0x2f, 0x74, 0x65, 0x73, 0x74, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61, 0x6d, 0x01, 0x00, 0x00, 0x01,
		// Footer (16 bytes)
		0x00, 0x63, 0x77, 0x6d, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	if _, err := cf.Write(counterData); err != nil {
		return fmt.Errorf("failed to write counter data: %w", err)
	}

	fmt.Printf("Generated working counter file: %s\n", counterFilePath)
	
	return nil
}

func main() {
	if err := generateWorkingSynthetic("test_working"); err != nil {
		fmt.Printf("Error: %v\n", err)
		os.Exit(1)
	}
}