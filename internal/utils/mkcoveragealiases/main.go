// Command mkcoveragealiases creates a mirror of a subset of packages + exported symbols
// from internal/coverage into ./coverage/.
package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"strings"
)

// Define which packages to mirror
var packagesToMirror = map[string]bool{
	"pods":          true,
	"cmerge":        true,
	"cformat":       true,
	"decodemeta":    true,
	"decodecounter": true,
	"encodemeta":    true,
	"encodecounter": true,
	"stringtab":     true,
	"slicereader":   true,
	"slicewriter":   true,
	"uleb128":       true,
	// Add more packages as needed
}

// Define any types or constants from defs.go to include
var defsToInclude = map[string]bool{
	"CoverableUnit":             true,
	"CovCounterSet":             true,
	"CovMetaFileReader":         true,
	"PkgIdExport":               true,
	"CoverMetaBlob":             true,
	"CounterMode":               true,
	"CounterModeCold":           true,
	"CounterModeSet":            true,
	"CounterModeCount":          true,
	"CounterModeAtomic":         true,
	"FileMetaBlob":              true,
	"FileMetaBlobHeader":        true,
	"CounterFileHeader":         true,
	"CounterDataBlob":           true,
	"MergeMode":                 true,
	"MergeModeCounter":          true,
	"MergeModeFunc":             true,
	"MergeModePkg":              true,
	"OutputMode":                true,
	"OutputModeSet":             true,
	"OutputModeCount":           true,
	"OutputModeAtomic":          true,
	"CovMetaFileReaderFactory":  true,
	"CounterVisibility":         true,
	"CounterVisibilityPublic":   true,
	"CounterVisibilityPrivate":  true,
	"CounterVisibilityInternal": true,
	"CounterGranularity":        true,
	"CounterGranularityFunc":    true,
	"CounterGranularityBlock":   true,
	// Add more types/constants as needed
}

func main() {
	// Create the base coverage directory if it doesn't exist
	if err := os.MkdirAll("coverage", 0755); err != nil {
		log.Fatalf("Failed to create coverage directory: %v", err)
	}

	// Copy package.go file with package documentation
	createPackageFile()

	// Process and mirror defs.go
	mirrorDefsFile()

	// Mirror selected packages
	for pkg := range packagesToMirror {
		mirrorPackage(pkg)
	}

	fmt.Println("Coverage mirror created successfully in ./coverage/")
}

// createPackageFile creates a package.go file with package documentation
func createPackageFile() {
	content := `// Package coverage provides access to Go coverage data.
// It is a mirror of selected exported symbols from internal/coverage.
package coverage

// This file was generated by github.com/tmc/covutil/utils/internal/mkcoveragealiases
`
	if err := os.WriteFile("coverage/package.go", []byte(content), 0644); err != nil {
		log.Fatalf("Failed to write package.go: %v", err)
	}
}

// mirrorDefsFile processes the defs.go file and extracts selected types and constants
func mirrorDefsFile() {
	fset := token.NewFileSet()
	srcPath := "internal/coverage/defs.go"
	f, err := parser.ParseFile(fset, srcPath, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("Failed to parse %s: %v", srcPath, err)
	}

	var output strings.Builder
	output.WriteString("// Package coverage provides access to Go coverage data.\n")
	output.WriteString("// This file contains selected types and constants from internal/coverage/defs.go\n")
	output.WriteString("package coverage\n\n")

	// Extract declarations that match our filter
	for _, decl := range f.Decls {
		switch d := decl.(type) {
		case *ast.GenDecl:
			if d.Tok == token.TYPE || d.Tok == token.CONST {
				hasMatch := false
				for _, spec := range d.Specs {
					if typeSpec, ok := spec.(*ast.TypeSpec); ok {
						if defsToInclude[typeSpec.Name.Name] {
							hasMatch = true
							break
						}
					} else if valueSpec, ok := spec.(*ast.ValueSpec); ok {
						for _, name := range valueSpec.Names {
							if defsToInclude[name.Name] {
								hasMatch = true
								break
							}
						}
						if hasMatch {
							break
						}
					}
				}

				if hasMatch {
					// Get the source code for this declaration
					startPos := fset.Position(d.Pos())
					endPos := fset.Position(d.End())

					// Read the file
					src, err := os.ReadFile(srcPath)
					if err != nil {
						log.Fatalf("Failed to read %s: %v", srcPath, err)
					}

					// Extract the relevant lines
					lines := strings.Split(string(src), "\n")
					startLine := startPos.Line - 1
					endLine := endPos.Line - 1

					// Add the declaration to the output
					for i := startLine; i <= endLine; i++ {
						output.WriteString(lines[i])
						output.WriteString("\n")
					}
					output.WriteString("\n")
				}
			}
		}
	}

	// Write the output to defs.go in the coverage directory
	if err := os.WriteFile("coverage/defs.go", []byte(output.String()), 0644); err != nil {
		log.Fatalf("Failed to write coverage/defs.go: %v", err)
	}
}

// mirrorPackage mirrors a single package from internal/coverage to ./coverage
func mirrorPackage(pkgName string) {
	srcDir := filepath.Join("internal/coverage", pkgName)
	destDir := filepath.Join("coverage", pkgName)

	// Create the package directory
	if err := os.MkdirAll(destDir, 0755); err != nil {
		log.Fatalf("Failed to create directory %s: %v", destDir, err)
	}

	// Walk through the source directory and copy each Go file (excluding tests)
	err := filepath.WalkDir(srcDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		// Skip directories and test files
		if d.IsDir() || strings.HasSuffix(d.Name(), "_test.go") {
			return nil
		}

		// Only process .go files
		if !strings.HasSuffix(d.Name(), ".go") {
			return nil
		}

		// Get the relative path from the source directory
		relPath, err := filepath.Rel(srcDir, path)
		if err != nil {
			return fmt.Errorf("failed to get relative path: %w", err)
		}

		// Construct the destination path
		destPath := filepath.Join(destDir, relPath)

		// Make sure the destination directory exists
		if err := os.MkdirAll(filepath.Dir(destPath), 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", filepath.Dir(destPath), err)
		}

		// Process and copy the file, rewriting the package name
		if err := processGoFile(path, destPath, pkgName); err != nil {
			return fmt.Errorf("failed to process %s: %w", path, err)
		}

		return nil
	})

	if err != nil {
		log.Fatalf("Failed to mirror package %s: %v", pkgName, err)
	}
}

// processGoFile reads a Go file, rewrites its package name, and writes it to the destination
func processGoFile(srcPath, destPath, pkgName string) error {
	// Parse the source file
	fset := token.NewFileSet()
	srcFile, err := parser.ParseFile(fset, srcPath, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("failed to parse %s: %w", srcPath, err)
	}

	// Rewrite internal imports to use our coverage package
	rewriteImports(srcFile)

	// Change the package name from the original to "package [pkgName]"
	srcFile.Name.Name = pkgName

	// Open the source file to read its content
	srcContent, err := os.ReadFile(srcPath)
	if err != nil {
		return fmt.Errorf("failed to read %s: %w", srcPath, err)
	}

	// Open the destination file for writing
	destFile, err := os.Create(destPath)
	if err != nil {
		return fmt.Errorf("failed to create %s: %w", destPath, err)
	}
	defer destFile.Close()

	// Add a header comment
	header := fmt.Sprintf("// Package %s mirrors functionality from internal/coverage/%s.\n// Generated by github.com/tmc/covutil/utils/internal/mkcoveragealiases\n",
		pkgName, pkgName)
	if _, err := destFile.WriteString(header); err != nil {
		return fmt.Errorf("failed to write header: %w", err)
	}

	// Write the package declaration
	if _, err := destFile.WriteString(fmt.Sprintf("package %s\n\n", pkgName)); err != nil {
		return fmt.Errorf("failed to write package declaration: %w", err)
	}

	// Process imports
	if len(srcFile.Imports) > 0 {
		if _, err := destFile.WriteString("import (\n"); err != nil {
			return fmt.Errorf("failed to write import opening: %w", err)
		}

		for _, imp := range srcFile.Imports {
			importPath := imp.Path.Value

			// Rewrite internal/coverage imports to reference our coverage package
			if strings.Contains(importPath, "internal/coverage") {
				subPkg := strings.TrimPrefix(
					strings.TrimSuffix(importPath, "\""),
					"\"internal/coverage/")

				// Skip imports to packages we're not mirroring
				if !packagesToMirror[subPkg] && subPkg != "" {
					continue
				}

				if subPkg == "" {
					// Main package import
					if imp.Name != nil {
						if _, err := destFile.WriteString(fmt.Sprintf("\t%s \"github.com/tmc/covutil/coverage\"\n", imp.Name.Name)); err != nil {
							return fmt.Errorf("failed to write import: %w", err)
						}
					} else {
						if _, err := destFile.WriteString("\t\"github.com/tmc/covutil/coverage\"\n"); err != nil {
							return fmt.Errorf("failed to write import: %w", err)
						}
					}
				} else {
					// Subpackage import
					if imp.Name != nil {
						if _, err := destFile.WriteString(fmt.Sprintf("\t%s \"github.com/tmc/covutil/coverage/%s\"\n", imp.Name.Name, subPkg)); err != nil {
							return fmt.Errorf("failed to write import: %w", err)
						}
					} else {
						if _, err := destFile.WriteString(fmt.Sprintf("\t\"github.com/tmc/covutil/coverage/%s\"\n", subPkg)); err != nil {
							return fmt.Errorf("failed to write import: %w", err)
						}
					}
				}
			} else {
				// Keep other imports as they are
				if imp.Name != nil {
					if _, err := destFile.WriteString(fmt.Sprintf("\t%s %s\n", imp.Name.Name, importPath)); err != nil {
						return fmt.Errorf("failed to write import: %w", err)
					}
				} else {
					if _, err := destFile.WriteString(fmt.Sprintf("\t%s\n", importPath)); err != nil {
						return fmt.Errorf("failed to write import: %w", err)
					}
				}
			}
		}

		if _, err := destFile.WriteString(")\n\n"); err != nil {
			return fmt.Errorf("failed to write import closing: %w", err)
		}
	}

	// Copy the rest of the file content except for the package declaration and imports
	lines := strings.Split(string(srcContent), "\n")
	inImports := false

	for i, line := range lines {
		// Skip the package declaration line
		if i == 0 && strings.HasPrefix(line, "package") {
			continue
		}

		// Detect the start of the imports section
		if strings.HasPrefix(line, "import") {
			inImports = true
			continue
		}

		// If we're in the imports section and we find a closing ), we're done with imports
		if inImports && strings.Contains(line, ")") {
			inImports = false
			continue
		}

		// Skip lines in the imports section
		if inImports {
			continue
		}

		// Write the line
		if _, err := destFile.WriteString(line + "\n"); err != nil {
			return fmt.Errorf("failed to write line: %w", err)
		}
	}

	return nil
}

// rewriteImports rewrites import paths from internal/coverage to github.com/tmc/covutil/coverage
func rewriteImports(f *ast.File) {
	for _, imp := range f.Imports {
		importPath := strings.Trim(imp.Path.Value, "\"")
		if strings.HasPrefix(importPath, "internal/coverage") {
			subPkg := strings.TrimPrefix(importPath, "internal/coverage/")
			if subPkg == "" {
				imp.Path.Value = "\"github.com/tmc/covutil/coverage\""
			} else {
				imp.Path.Value = fmt.Sprintf("\"github.com/tmc/covutil/coverage/%s\"", subPkg)
			}
		}
	}
}
